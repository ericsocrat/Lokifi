"""
Mock fixtures for unified_asset_service

Auto-generated by Lokifi Mock Generator
Provides comprehensive mocks for external dependencies
"""
import pytest
from unittest.mock import Mock, AsyncMock, MagicMock, patch
from typing import Any, Dict, List, Optional

# ============================================================================
# HTTPX MOCKS
# ============================================================================

@pytest.fixture
def mock_httpx_response():
    """ Mock HTTP response """
    response = AsyncMock()
    response.status_code = 200
    response.json = AsyncMock(return_value={})
    response.text = ""
    response.content = b""
    response.headers = {}
    response.raise_for_status = Mock()
    return response


@pytest.fixture
def mock_httpx_client(mock_httpx_response):
    """ Mock httpx AsyncClient """
    client = AsyncMock()
    client.get = AsyncMock(return_value=mock_httpx_response)
    client.post = AsyncMock(return_value=mock_httpx_response)
    client.put = AsyncMock(return_value=mock_httpx_response)
    client.delete = AsyncMock(return_value=mock_httpx_response)
    client.patch = AsyncMock(return_value=mock_httpx_response)
    client.aclose = AsyncMock()

    # Support context manager
    client.__aenter__ = AsyncMock(return_value=client)
    client.__aexit__ = AsyncMock()

    return client


@pytest.fixture
def mock_httpx_error():
    """ Mock httpx error scenarios """
    return {
        'timeout': lambda: httpx.TimeoutException("Request timeout"),
        'network': lambda: httpx.NetworkError("Network error"),
        'http': lambda: httpx.HTTPError("HTTP error"),
        'status': lambda code: httpx.HTTPStatusError("Status error", request=Mock(), response=Mock(status_code=code))
    }

# ============================================================================
# REDIS MOCKS
# ============================================================================

@pytest.fixture
def mock_redis_client():
    """ Mock Redis client """
    client = AsyncMock()
    client.ping = AsyncMock(return_value=True)
    client.get = AsyncMock(return_value=None)
    client.set = AsyncMock(return_value=True)
    client.delete = AsyncMock(return_value=1)
    client.exists = AsyncMock(return_value=0)
    client.expire = AsyncMock(return_value=True)
    client.keys = AsyncMock(return_value=[])
    client.flushdb = AsyncMock(return_value=True)
    client.flushall = AsyncMock(return_value=True)

    # Hash operations
    client.hget = AsyncMock(return_value=None)
    client.hset = AsyncMock(return_value=1)
    client.hgetall = AsyncMock(return_value={})
    client.hdel = AsyncMock(return_value=1)

    # List operations
    client.lpush = AsyncMock(return_value=1)
    client.rpush = AsyncMock(return_value=1)
    client.lpop = AsyncMock(return_value=None)
    client.rpop = AsyncMock(return_value=None)
    client.lrange = AsyncMock(return_value=[])

    # Set operations
    client.sadd = AsyncMock(return_value=1)
    client.smembers = AsyncMock(return_value=set())
    client.srem = AsyncMock(return_value=1)

    return client


@pytest.fixture
def mock_redis_cache():
    """ Mock Redis cache with get/set behavior """
    cache = {}

    async def mock_get(key):
        return cache.get(key)

    async def mock_set(key, value, expire=None):
        cache[key] = value
        return True

    async def mock_delete(key):
        if key in cache:
            del cache[key]
            return 1
        return 0

    client = AsyncMock()
    client.get = mock_get
    client.set = mock_set
    client.delete = mock_delete
    client.exists = AsyncMock(side_effect=lambda k: 1 if k in cache else 0)

    return client

# ============================================================================
# FASTAPI MOCKS
# ============================================================================

@pytest.fixture
def mock_request():
    """ Mock FastAPI Request """
    request = Mock()
    request.headers = {}
    request.cookies = {}
    request.query_params = {}
    request.path_params = {}
    request.url = Mock(path="/", query="")
    request.client = Mock(host="127.0.0.1", port=8000)
    request.method = "GET"
    return request


@pytest.fixture
def mock_websocket():
    """ Mock WebSocket connection """
    ws = AsyncMock()
    ws.accept = AsyncMock()
    ws.send_text = AsyncMock()
    ws.send_json = AsyncMock()
    ws.receive_text = AsyncMock(return_value="")
    ws.receive_json = AsyncMock(return_value={})
    ws.close = AsyncMock()
    return ws

